
//////////////////////////////////////////////////////////////////////////
//
// FILE:  sm_apiCtilMgr.h
// DESCRIPTION:
//  This include file was created to allow a certain isolation from the
//  SFL definitions for shared lo-level operations.
//
// Last Updated:	16 December 2004                                       
//                Req Ref:  SMP RTM #5  AES Crypto++                                
//                Sue Beauchamp <Sue.Beauchamp@it.baesystems.com>        
//
//////////////////////////////////////////////////////////////////////////
#ifndef _SM_APICTILMGR_H_
#define _SM_APICTILMGR_H_

#ifndef LIBCTILMGRDLL_API      // DEFINE on compile line to "" for Static refs
#ifdef WIN32
#ifdef LIBCTILMGRDLL_EXPORTS
#define LIBCTILMGRDLL_API __declspec(dllexport)
#else
#define LIBCTILMGRDLL_API __declspec(dllimport)
#endif          // LIBCTILMGRDLL_EXPORTS
#else           // Handle Unix...
#define LIBCTILMGRDLL_API
#endif          // WIN32
#endif          // ifndef LIBCTILMGRDLL_API

#ifndef NO_NAMESPACE
#define _BEGIN_CTIL_NAMESPACE namespace CTIL {
#define _END_CTIL_NAMESPACE }
#else
#define _BEGIN_CTIL_NAMESPACE
#define _END_CTIL_NAMESPACE
#endif


// SPECIFY SPECIFIC OVERRIDE STRUCTURE ALIGNMENT FACTOR;
//  NECESSARY TO OVERRIDE ANY OTHER PROJECT SETTINGS in which this include may
//  be referenced.  This alignment forces all references to the SFL structures
//  to be consistent with the DLL/LIB objects.
#ifdef WIN32
#pragma pack(8)
#pragma warning( disable : 4127 4710 )
#endif
//
//

#include "asn-incl.h"
#include "sm_usefulTypes.h"
#include "asn-listset.h"
#include "sm_apicCtilMgr.h"
#include "sm_DLLInterface.h"
#include "sm_vdasnaccMgr.h"
#include "sm_buffer.h"
#include <string>

_BEGIN_CTIL_NAMESPACE 

// SM_INST_* defines are used to identify instances that
// the application wants to lock, unlock, or clear
#define SM_INST_APPLICABLE 0x01
#define SM_INST_USE_THIS 0x02
#define SM_INST_ALL 0x04

// Algorithm parameters
#define SM_DSA_P_LEN       128
#define SM_DSA_Q_LEN       20
#define SM_DSA_G_LEN       128

#define SM_DSA_R_SIZE      20
#define SM_DSA_S_SIZE      20

// Forward class LIBCTILMGRDLL_API Declarations //
///////////////////////////////////////////////
class CSM_AlgVDA;
class CSM_CtilMgr;
class CSM_CtilInst;

// HERE IS A DECLARATION FOR A GLOBAL OVERRIDE OF THE INSERTION OPERATOR
//   This is so we can control output formatting regardless of where the
//   application directs the output (screen, file or memory).
//RWC;8/2/01;ostream LIBCTILMGRDLL_API &operator << (ostream &os, char *a);

///////////////////////
// List Declarations //
///////////////////////
// CSM_List is fashioned after the linked list generated by the SNACC
// compiler.  The implementation of this class LIBCTILMGRDLL_API is in sm_tlist.h.


//////////////////////////////////////////////////////////////////////////

//
template <class T>
class List : public std::list<T>
{
public:
	// Appends newly inserted element to list and returns its iterator
	typename std::list<T>::iterator append(const T& x = T())			{ return insert(this->end(), x); }
};      // END List


// List Typedefs
typedef List<CSM_AlgVDA> CSM_AlgLstVDA;
typedef List<CTIL::CSM_Buffer> CSM_BufferLst;
typedef List<CSM_CtilInst *> CSM_CtilInstLst;

//////////////////////////////////////
// CLASS LIBCTILMGRDLL_API DEFINITIONS //
//////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
//
class LIBCTILMGRDLL_API CSM_ThreadLock
{
private:
    void *m_pThreadLock;  // Platform specific.  Not defined here to avoid
                        //  unnecessary includes for general apps.  See source.
    long m_lRefCount;   // Locking reference counter.
public:
    CSM_ThreadLock();
    ~CSM_ThreadLock();
    void threadLock();
    void threadUnlock();
};


//////////////////////////////////////////////////////////////////////////
class LIBCTILMGRDLL_API CSM_AlgVDA: public SNACC::AlgorithmIdentifierVDA
                  // RWC; made public for consistent use.
{
public:
   // CONSTRUCTORS
   CSM_AlgVDA() { }
   CSM_AlgVDA(SNACC::AsnOid &AlgOid) { algorithm = AlgOid; }
   CSM_AlgVDA(SNACC::AlgorithmIdentifierVDA &SNACCAlgId);
   CSM_AlgVDA(SNACC::AsnOid &AlgOid, CTIL::CSM_Buffer &buffer);
   CSM_AlgVDA(const CSM_AlgVDA &alg);

   // OPERATIONAL methods
   SNACC::AsnOid *GetId();
   CTIL::CSM_Buffer *GetParams();
   SNACC::AsnOid *AccessSNACCId() { return &algorithm; }

   SNACC::AlgorithmIdentifierVDA *GetSNACCAlgId();
   void SetSNACCAlgId(SNACC::AlgorithmIdentifierVDA *pSNACCAlgId);

   // OPERATORS
   bool operator == (CSM_AlgVDA &AlgId);
   bool operator != (CSM_AlgVDA &AlgId);
   CSM_AlgVDA &operator = (const CSM_AlgVDA &AlgId)
   { AlgorithmIdentifierVDA::operator =(AlgId);return(*this); }
   //RWC;CSM_AlgVDA &operator = (AlgorithmIdentifier &snaccAlg);
   //RWC;CSM_AlgVDA &operator = (SNACC::AsnOid &oid) { algorithm = oid; return *this; }
   static long LoadNullParams(SNACC::AlgorithmIdentifierVDA *pAlg);
   long LoadNullParams();
   static CTIL::CSM_Buffer *GetNullParams();
   bool HasNullParams();
};

//////////////////////////////////////////////////////////////////////////
// CSM_TokenInterface is not directly used by the application.
// It is used internally by the SFL to abstractly access crypto services.
class LIBCTILMGRDLL_API CSM_TokenInterface
{
protected:
   virtual SM_RET_VAL SMTI_ExtractKeyWrapFinish(
       CTIL::CSM_Buffer *pData,              // Output
       CTIL::CSM_Buffer &CEKICVPAD)
   { 
#ifdef WIN32
       CEKICVPAD;pData;/*AVOIDS warning*/
#endif
       return -1; }  // Input
public:

   // SMTI_Sign acquires the necessary X and parameters as
   // appropriate.  SMTI_Sign digests the data and returns the
   // digest in pDigest.  SMTI_Sign encrypts the digest and returns
   // the encrypted digest in pEncryptedDigest.
   virtual SM_RET_VAL SMTI_Sign(
       CTIL::CSM_Buffer *pData,              // input, data to be signed
       CTIL::CSM_Buffer *pEncryptedDigest,   // signature
       CTIL::CSM_Buffer *pDigest)=0;         // digest output

   // SMTI_Verify accepts the public key of the signer as input
   // and also the data that was signed.  Finally, it accepts
   // the signature (encrypted digest).  It returns
   // SM_NO_ERROR if the signature was verified successfully.
   virtual SM_RET_VAL SMTI_Verify(
       CTIL::CSM_Buffer *pSignerPublicKey,   // input
       CSM_AlgVDA    *pDigestAlg,         // input
       CSM_AlgVDA    *pSignatureAlg,      // input
       CTIL::CSM_Buffer *pData,              // input
       CTIL::CSM_Buffer *pSignature)=0;      // input

   // SMTI_Encrypt accepts the data to be encrypted.  It returns
   // the encrypted data and the IV.  The class derived from
   // this class must return the MEK for future use with
   // SMTI_GenerateEMEK.  In special cases such as hardware
   // fortezza where the MEK is not available, SMTI_Encrypt
   // may return a special phrase in the buffer to be
   // recognized by whatever CTI's regcognize it.  See the API
   // for a detailed explanation of this.
   virtual SM_RET_VAL SMTI_Encrypt(
       CTIL::CSM_Buffer *pData,         // input (data to be encrypted)
       CTIL::CSM_Buffer *pEncryptedData,// output
       CTIL::CSM_Buffer *pParameters,   // OUT, for KeyAgree algs.
       CTIL::CSM_Buffer *pMEK,          // In/output; may be specified.
       CTIL::CSM_Buffer *pIV=NULL) = 0; // In, to avoid specific
                                  // alg encoding by app.
   // SMTI_GenerateEMEK accepts the public key (Y) of the recipient
   // as input.  It protects the provided MEK
   // and returns the result in pEMEK.
   // SMTI_GenerateEMEK also generates a ukm, if applicable . . .
   virtual SM_RET_VAL SMTI_GenerateEMEK(
       CTIL::CSM_Buffer *pRecipient,    // input, Y of recip
       CTIL::CSM_Buffer *pParameters,   // output, parameters for alg.
       CTIL::CSM_Buffer *pMEK,          // input, MEK or special phrase
       CTIL::CSM_Buffer *pEMEK,         // output, encrypted MEK
       CTIL::CSM_Buffer *pUKM,          // output, ukm, if applicable
       CTIL::CSM_Buffer *pSubjKeyId=NULL)=0; // output, if applicable

   // SMTI_ExtractMEK accepts the public key (Y) of the originator
   // and the encrypted MEK as input.  In RSA's case, pOriginator
   // may be null, otherwise, it uses the Y in conjunction with
   // the recipient's X (available through this class) to generate
   // a TEK that can decrypt the EMEK thus resulting in the MEK.
   // pUKM is TBD
   virtual SM_RET_VAL SMTI_ExtractMEK(
       CTIL::CSM_Buffer *pOriginator,   // input, Y of originator
       CTIL::CSM_Buffer *pParameters,   // input, parameters for alg.
       CTIL::CSM_Buffer *pEMEK,         // input, encrypted MEK
       CTIL::CSM_Buffer *pUKM,          // input
       CTIL::CSM_Buffer *pMEK)=0;       // output

   // SMTI_Decrypt accepts the IV as input.
   // SMTI_Decrypt accepts the encrypted data as input.
   // SMTI_Decrypt uses the MEK extracted by SMTI_ExtractMEK to
   // decrypt the pEncryptedData.  It places the results in pData.
   virtual SM_RET_VAL SMTI_Decrypt(
       CTIL::CSM_Buffer *pParameters,   // input, parameters for alg.
       CTIL::CSM_Buffer *pEncryptedData,// input (data to be decrypted)
       CTIL::CSM_Buffer *pMEK,          // input (MEK or special phrase)
       CTIL::CSM_Buffer *pData)=0;      // output (decrypted data)

   // SMTI_DigestData digests the data in pData and returns the
   // result in pDigest
   virtual SM_RET_VAL SMTI_DigestData(
       CTIL::CSM_Buffer *pData,         // input
       CTIL::CSM_Buffer *pDigest)=0;    // output
   virtual SM_RET_VAL SMTI_DigestData(
       CTIL::CSM_Buffer *pData,     // input
       CTIL::CSM_Buffer *pDigest,   // output
       SNACC::AsnOid     &OidDigest);// input

   // SMTI_Random uses the seed data in pSeed to seed the random generator.
   // depending on the crypto token library implementation, this may be
   // unused.  SMTI_Random fills pRandom with lLength bytes of
   // random data.
   virtual SM_RET_VAL SMTI_Random(
       CTIL::CSM_Buffer *pSeed,         // input
       CTIL::CSM_Buffer *pRandom,       // input/output
       SM_SIZE_T lLength)=0;      // input
   virtual SM_RET_VAL SMTI_GenerateKeyAgreement(
       CTIL::CSM_Buffer *pRecipient,    // input, Y of recip
       CTIL::CSM_Buffer *pParameters,   // IN,OUT may be passed in for shared
                                  //  use OR for ESDH. (p, g, and/or IV).
       CTIL::CSM_Buffer *pUKM,          // input/output may be passed in for shared
                                  //   use.  UserKeyMaterial (random number).
       CTIL::CSM_Buffer *pbufferIV,     // input/output may be passed in for
                                  //   shared use. Initialization vector,
                                  //   part of DH params.
       SNACC::AsnOid *pEncryptionOID,   // IN, specified encryption of key,
                                  //   used here in key generation,
                                  //   but alg not implemented.
       CTIL::CSM_Buffer *pbufKeyAgree,  // output, encryption key for this recip.
       long lKekLength)           // Input, for OtherInfo load.
   { 
#ifdef WIN32
     pRecipient;pParameters;pUKM;pbufferIV;pEncryptionOID;pbufKeyAgree;
     lKekLength;/*AVOIDS warnings*/
#endif
     return -1; }                 // Default is not supported by
                                  // CTIL library.
   virtual SM_RET_VAL SMTI_GenerateKeyWrap(
       CTIL::CSM_Buffer *pData,         // input (data to be encrypted)
       CTIL::CSM_Buffer *pEncryptedData,// output
       CTIL::CSM_Buffer *pParameters,   // OUT, for KeyAgree algs.
       CTIL::CSM_Buffer *pMEK,          // In/output; may be specified.
       CTIL::CSM_Buffer *pIV)           // In, to avoid specific
                                  // alg encoding by app.
   { 
#ifdef WIN32
     pData;pEncryptedData;pParameters;pMEK;pIV;/*AVOIDS warning*/
#endif
     return -1; } 

   virtual SM_RET_VAL SMTI_GeneratePWRIKeyWrap(
            CSM_Buffer *pData, // input  cek to be encrypted by KEK derived from password
            CSM_Buffer *pEncryptedData, // output
            CSM_Buffer *pIV,  // In, to avoid specific alg encoding by app. salt
            CSM_Buffer *pPassword,  
            CSM_Buffer *pUserKeyEncryptionKey, // optional
            CSM_AlgVDA    *&pPWRIDerivationAlg,  // IN, PWRI id-PBKDF2 for now
            CSM_AlgVDA    *&pPWRIEncryptionAlg)  // IN, PWRI id-alg-PWRI-KEK for now

                                  // alg encoding by app.
   { 
#ifdef WIN32
     pData;pEncryptedData;pPassword;pIV;/*AVOIDS warning*/
     pPWRIDerivationAlg; pPWRIEncryptionAlg; pUserKeyEncryptionKey;
#endif
     return -1; 
   }  

   virtual SM_RET_VAL SMTI_ExtractPWRIKeyWrap(
            CSM_Buffer &MEK, // Output
            const CSM_Buffer EncryptedData, // input
            const CSM_Buffer Password, // IN password
            CSM_Buffer *pUserKeyEncryptionKey, // optional
                  CSM_AlgVDA    *pPWRIDerivationAlg,  // IN, OUT PWRI id-PBKDF2 for now
                  CSM_AlgVDA    *pPWRIEncryptionAlg)  // IN, OUT PWRI id-alg-PWRI-KEK for now
   { 
#ifdef WIN32
     MEK;EncryptedData;Password;pPWRIDerivationAlg;/*AVOIDS warning*/
     pPWRIEncryptionAlg; pUserKeyEncryptionKey;
#endif
     return -1; 
   } 
     
   // NOT SUPPORTED BY DEFAULT.
   virtual CTIL::CSM_Buffer *SMTI_GenerateKeyWrapIV(
       long &lKekLength,          // OUT, returned algorithm specific length
       CSM_AlgVDA *pWrapAlg=NULL)    // OUT, returned since params are alg
   { 
#ifdef WIN32
      lKekLength;pWrapAlg;/*AVOIDS warning*/
#endif
      return NULL; }

   virtual SM_RET_VAL SMTI_ExtractKeyAgreement(
       CTIL::CSM_Buffer *pOriginator,   // input, Y of originator
//       CTIL::CSM_Buffer *pParameters, // IN,OUT may be passed in for shared
                                  //   use OR for ESDH. (p, g, and/or IV).
       CTIL::CSM_Buffer *pUKM,          // input/output may be passed in for
                                  //   shared use.  UserKeyMaterial
                                  //   (random number).
       CTIL::CSM_Buffer *pbufferIV,     // input/output may be passed in for
                                  //   shared use. Initialization vector,
                                  //   part of DH params.
       SNACC::AsnOid *pEncryptionOID,   // IN, specified encryption of key,
                                  //   used here in key generation,
                                  //   but alg not implemented.
       CTIL::CSM_Buffer *pbufKeyAgree,  // output, encryption key for this recip.
       long lKekLength)           // Output, from OtherInfo load.
   {  
#ifdef WIN32
       pOriginator;pUKM;pbufferIV;pEncryptionOID;pbufKeyAgree;lKekLength;
      /*AVOIDS warning*/
#endif

       return -1; }
   virtual SM_RET_VAL SMTI_ExtractKeyWrap(
       CTIL::CSM_Buffer *pData,         // Output
       CTIL::CSM_Buffer *pEncryptedData,// input
       CTIL::CSM_Buffer *pParameters,   // IN, for KeyAgree algs.
       CTIL::CSM_Buffer *pTEK,          // output
       CTIL::CSM_Buffer *pIV)           // In
   { 
#ifdef WIN32
      pData;pEncryptedData;pParameters;pTEK;pIV;/*AVOIDS warning*/
#endif
      return -1; } 
   virtual SM_RET_VAL SMTI_GetStatus() { return SM_NO_ERROR; } 

   virtual void SMTI_DeleteMEK() {};

   // SMTI_Lock and SMTI_Unlock should be used by the calling hilevel
   // member to lock the crypto resource.  This is particularly applicable
   // to Encrypt/GenerateEMEK and ExtractMEK/Decrypt sequences...
   virtual SM_RET_VAL SMTI_Lock()=0;
   virtual SM_RET_VAL SMTI_Unlock()=0;
   virtual bool SMTI_IsKeyAgreement()=0;  // TRUE indicates key agreement
                                          //  encryption, not key transfer.

   // the following pure virtual members are overriding by co-derived class
   // CSM_BaseTokenInterface
   virtual void BTISetPreferredCSInstAlgs(SNACC::AsnOid *oidDigest,
       SNACC::AsnOid *oidDigestEncryption,
       SNACC::AsnOid *oidKeyEncryption,
       SNACC::AsnOid *oidContentEncryption)=0;
   virtual void BTIGetPreferredCSInstAlgs(SNACC::AsnOid *&oidDigest,
       SNACC::AsnOid *&oidDigestEncryption,
       SNACC::AsnOid *&oidKeyEncryption,
       SNACC::AsnOid *&oidContentEncryption)=0;
   virtual void BTISetAlgIDs(CSM_AlgLstVDA *pdigestAlgID,
       CSM_AlgLstVDA *pdigestEncryptionAlgID,
       CSM_AlgLstVDA *pkeyEncryptionAlgID,
       CSM_AlgLstVDA *pcontentEncryptionAlgID)=0;
   virtual void BTIGetAlgIDs(CSM_AlgLstVDA **ppdigestAlgID,
       CSM_AlgLstVDA **ppdigestEncryptionAlgID,
       CSM_AlgLstVDA **ppkeyEncryptionAlgID,
       CSM_AlgLstVDA **ppcontentEncryptionAlgID)=0;
   virtual bool BTIFindAlgIds(CSM_AlgVDA *pdigestAlgID,
       CSM_AlgVDA *pdigestEncryptionAlgID,
       CSM_AlgVDA *pkeyEncryptionAlgID,
       CSM_AlgVDA *pcontentEncryptionAlgID)=0;
   virtual SNACC::AsnOid* GetPrefDigest()=0;
   virtual SNACC::AsnOid* GetPrefDigestEncryption()=0;
   virtual SNACC::AsnOid* GetPrefKeyEncryption()=0;
   virtual SNACC::AsnOid* GetPrefContentEncryption()=0;
   virtual SNACC::AsnOid* GetLocalKeyAlg()=0;
   virtual void SetLocalKeyAlg(SNACC::AsnOid *poid)=0;

   virtual void CSM_TokenInterfaceDestroy()=0;

   //RWC; added to support E-S DH and public key, no cert features.
   virtual CTIL::CSM_Buffer *GetDynamicPublicKey(CSM_AlgVDA &Alg) {
#ifdef WIN32
       Alg;
#endif
       return NULL;}
                                           // May return Certs or pub key.
   virtual void ClearDynamicKey() { };     // Defaults to do nothing; only
                //  necessary for CTIL algs that generate dynamic keys;
                //   this reset will force generation of a new key.
   virtual CSM_AlgVDA *DeriveMsgAlgFromCert(CSM_AlgVDA &Alg)
   { CSM_AlgVDA *pResultAlg = new CSM_AlgVDA(Alg);
     return pResultAlg;}
                // This call interprets KARI certificate params into CMS Msg
                //  Param format for algorithms.  It is up to the CTIL to
                //  properly interpret algorithm specific formats for both.
   virtual void *AccessCSInst() {return NULL;}
   virtual void SetCSInst(void *pInst) = 0;

                        // This method returns an optional instance pointer
                        //  from the token, from the CTIL itself, if available.
                        //  It is a "void *" since the datatype is unknown in
                        //  this include file (CSM_CSInst, only CSM_CtilInst
                        //  is known in this library).
};

//////////////////////////////////////////////////////////////////////////
// CSM_BaseTokenInterface is not directly used by the application.
// CSM_BaseTokenInterface contains base token interface information
// common to all classes derived from the CSM_TokenInterface
class LIBCTILMGRDLL_API CSM_BaseTokenInterface : public CSM_TokenInterface
{
private:
   //SNACC::CSM_ErrorBuf *m_pErrorBuf; // usually points to CSMIME error buf

   CSM_AlgLstVDA *m_pDigestAlgorithms;
   CSM_AlgLstVDA *m_pDigestEncryptionAlgorithms;
   CSM_AlgLstVDA *m_pKeyEncryptionAlgorithms;
   CSM_AlgLstVDA *m_pContentEncryptionAlgorithms;
   // private preferred algorithms for encryption and signing operations, if
   //  there are multiple choices.  These can be overriden by the application.
   //  They should be set by the logon process to a default algorithm from the
   //  above "SM_AlgList" parameters.
   SNACC::AsnOid m_digestOID;
   SNACC::AsnOid m_digestEncryptionOID;
   SNACC::AsnOid m_keyEncryptionOID;
   SNACC::AsnOid m_contentEncryptionOID;
   SNACC::AsnOid m_localKeyOID;

   //
   protected:
    CSM_ThreadLock m_ThreadLock;  // For thread control of this specific token.

public:
   CSM_BaseTokenInterface()
   {
       //m_pErrorBuf = NULL;
       m_pDigestAlgorithms = m_pDigestEncryptionAlgorithms =
           m_pKeyEncryptionAlgorithms =
           m_pContentEncryptionAlgorithms = NULL;
   }
   virtual ~CSM_BaseTokenInterface();

   // BTISetPreferrredCSInstAlgs will set the preferred encryption and
   //  signing algorithms by SNACC::AsnOid.  They must be part of the listed
   //  algorithms supported algorithms by SNACC::AsnOid.  They must be part of
   //  the listed algorithms supported by this session or the member
   //  function will return an error (non-zero).  NULL parameter are
   //  acceptable to allow the default session algorithms.
   void BTISetPreferredCSInstAlgs(SNACC::AsnOid *oidDigest,
                                  SNACC::AsnOid *oidDigestEncryption,
                                  SNACC::AsnOid *oidKeyEncryption,
                                  SNACC::AsnOid *oidContentEncryption);
   void BTIGetPreferredCSInstAlgs(SNACC::AsnOid *&oidDigest,
                                  SNACC::AsnOid *&oidDigestEncryption,
                                  SNACC::AsnOid *&oidKeyEncryption,
                                  SNACC::AsnOid *&oidContentEncryption);
   SNACC::AsnOid* GetPrefDigest();
   SNACC::AsnOid* GetPrefDigestEncryption();
   SNACC::AsnOid* GetPrefKeyEncryption();
   SNACC::AsnOid* GetPrefContentEncryption();

   // The local key alg is used for local key encryption/decryption
   // and may differ from the standard key encyrption algorithm OID
   SNACC::AsnOid* GetLocalKeyAlg();
   void SetLocalKeyAlg(SNACC::AsnOid *poid);

   void ClearDigestEncryptionCapability();
   void ClearKeyEncryptionCapability();
   void BTISetAlgIDs(CSM_AlgLstVDA *pdigestAlgID,
                     CSM_AlgLstVDA *pdigestEncryptionAlgID,
                     CSM_AlgLstVDA *pkeyEncryptionAlgID,
                     CSM_AlgLstVDA *pcontentEncryptionAlgID);
   void BTIGetAlgIDs(CSM_AlgLstVDA **ppdigestAlgID,
                     CSM_AlgLstVDA **ppdigestEncryptionAlgID,
                     CSM_AlgLstVDA **ppkeyEncryptionAlgID,
                     CSM_AlgLstVDA **ppcontentEncryptionAlgID);
   // BTIFindAlgIds will return true if all of the specified Algorithm IDs
   //  are located within this session instance.  Parameters may be NULL.
   bool BTIFindAlgIds(CSM_AlgVDA *pdigestAlgID,
                      CSM_AlgVDA *pdigestEncryptionAlgID,
                      CSM_AlgVDA *pkeyEncryptionAlgID,
                      CSM_AlgVDA *pcontentEncryptionAlgID);


};


typedef List<CSM_TokenInterfaceDLL> CSM_LstTokenInterfaceDLL;

//////////////////////////////////////////////////////////////////////////
// CSM_CtilMgr contains the CSInst instances as well as overall library
// information (including the error handling buffers)
class LIBCTILMGRDLL_API CSM_CtilMgr
{
private:
    // DATA MEMBERS
    enum FindType { FIND_TYPE_DN=0, FIND_TYPE_ID };
    // MEMBER FUNCTION
    CSM_CtilInst *FindInst(char *pStr, FindType type);
    static CSM_LstTokenInterfaceDLL m_TIList; // List for Dynamic loaded CTIL DLLs.
                // "m_TIList" was made "static" to force the Linux exit process
                //  to destroy/unload the shared objects on exit, instead of 
                //  having the application unload explicitely.  This fixed some
                //  some crash problems when using GCC 3.2.2 and RedHat 7.1/2/3.

protected:
    static CSM_ThreadLock m_ThreadLock;  // For thread control of .so/.dll list.
                // This lock is only necessary because of the "static" CTIL list.

public:
    // DATA MEMBER
    CSM_CtilInstLst *m_pCSInsts; // instance list

    void SetDefaultCTIL();
    // constructors and destructors
    CSM_CtilMgr();
    ~CSM_CtilMgr();

    // MEMBER FUNCTIONS
    // UseAll marks every instance's UseThis to true
    void UseAll();
    void UseAllEncryptors();

    // Find the first instance in list that contains the following list
    //  of algorithms.  Any of the parameters may be NULL; a instance is
    //  returned only if all specified algorithms are present
    CSM_CtilInst *FindCSInstAlgIds(CSM_AlgVDA *pdigestAlgID,
                                 CSM_AlgVDA *pdigestEncryptionAlgID,
                                 CSM_AlgVDA *pkeyEncryptionAlgID,
                                 CSM_AlgVDA *pcontentEncryptionAlgID);

    // returns a pointer to the SNACC::CSM_ErrorBuf class (error information)
    //SNACC::CSM_ErrorBuf *AccessErrorBuf() { return &m_ErrorBuf; }

    //  FindCommonContentOID will determine a common Content algorithm based on
    //  the specified recipient(s).  If more than one recipient is
    //  specified, then an attempt is made to find a content encryption
    //  algorithm common to each pair-wise key encryption algorithm
    SM_RET_VAL FindCommonContentOID(CSM_BufferLst *pRecipCerts,
                                    SNACC::AsnOid *pContentEncryptOID);// May be NULL


    // InstanceLock, InstanceUnlock, and the SM_INST_* defines are
    // used to SMTI_Lock and SMTI_Unlock groups of instances based on
    // their applicable flag (APPLICABLE), their UseThis flag (USE_THIS)
    // or a combination thereof . . .
    void InstanceLock(char chLockFlag);
    void InstanceUnlock(char chLockFlag);

    // ClearFlag clears the specified flags from the instances (APPLICABLE
    // and/or USE_THIS)  
    // This flag can be SM_INST_APPLICABLE, SM_INST_ALL, SM_INST_USE_THIS
    void ClearFlag(char chClearFlag);

    // ADDED BY PIERCE 7-13-99
    CSM_CtilInst *FindInstByID(char *pId);
    static char *ConvertDNString(char *pszDn);


    // RWC; Define DLL load operations.  The parameters to these calls may 
    // RWC;  reference certificates, but this library does not manage them.
   CSM_CtilInst *AddLogin(char *lpszDLLName, char *lpszBuildupArgs);
   CSM_TokenInterface *LookupDLLLibrary(SNACC::AlgorithmIdentifierVDA *pAlgID);
   CSM_LstTokenInterfaceDLL &GetTI_DLLLst() { return m_TIList; }
   CSM_CtilInst *AddDLLLibrary(char *lpszDLLName, char *lpszBuildupArgs);

};




//////////////////////////////////////////////////////////////////////////
// CSM_CtilInst is a "crypto service instance" or the class that provides
// access to the crypto services for an application and the SFL.
class LIBCTILMGRDLL_API CSM_CtilInst
{
private:
   CSM_TokenInterface *m_pTokenInterface;
   char *m_pszCSInstID;
   bool m_UseThis;
   bool m_Applicable;

   void Clear()
   {  m_pTokenInterface = NULL; m_pszCSInstID = NULL; 
      m_UseThis = true; m_Applicable = true;//Default ON.
      //m_pErrorBuf = NULL;
   }

public:
   CSM_CtilInst();
   virtual ~CSM_CtilInst();

   // SetTokenInterface and GetTokenInterface are not used by the
   // application under normal circumstances.  They are used by the SFL
   // and the CTI library
   void SetTokenInterface(CSM_TokenInterface *pTokenInterface);
   CSM_TokenInterface *AccessTokenInterface() { return m_pTokenInterface; }

   // The application can use AccessID and SetID to specify an identification
   // null terminated string for each instance
   // a default ID will be generated on construction
   char* AccessID() { return m_pszCSInstID; }
   void SetID(char *pszID);

   // The app can use SetUseThis to indicate that this instance should be
   // used for an origination operation
   void SetUseThis() { m_UseThis = true; }
   // sets the private UseThis flag based on the value of flag
   void SetUseThis(bool flag) { m_UseThis = flag; }

   // indicates if this instance is marked UseThis
   bool IsThisUsed() { return m_UseThis; }
   //RWC;CANNOT use since no certs to indicate private key present.;bool IsSigner ();

   // Indicates if the current instance can be used to verify or decrypt
   // a message that has been "Pre-processed"
   bool IsApplicable() { return m_Applicable; }
   // sets the private applicable flag, used only for the
   //  case where there were no sessions logged on when
   //  SM_PreProc() was called and the application needs
   //  to choose which sessions to use for verification or
   //  decryption.
   void SetApplicable() { m_Applicable = true; }
   // sets the private applicable flag based on the value of flag
   void SetApplicable(bool flag) { m_Applicable = flag; }

   // the following 5 methods call the corresponding BTI*
   // method in the m_pTokenInterface
   void SetPreferredCSInstAlgs(SNACC::AsnOid *oidDigest,
                               SNACC::AsnOid *oidDigestEncryption,
                               SNACC::AsnOid *oidKeyEncryption,
                               SNACC::AsnOid *oidContentEncryption);
   void GetPreferredCSInstAlgs(SNACC::AsnOid *oidDigest,
                               SNACC::AsnOid *oidDigestEncryption,
                               SNACC::AsnOid *oidKeyEncryption,
                               SNACC::AsnOid *oidContentEncryption);
   void SetAlgIDs(CSM_AlgLstVDA *pdigestAlgID,
                  CSM_AlgLstVDA *pdigestEncryptionAlgID,
                  CSM_AlgLstVDA *pkeyEncryptionAlgID,
                  CSM_AlgLstVDA *pcontentEncryptionAlgID);
   void GetAlgIDs(CSM_AlgLstVDA *&pdigestAlgID,
                  CSM_AlgLstVDA *&pdigestEncryptionAlgID,
                  CSM_AlgLstVDA *&pkeyEncryptionAlgID,
                  CSM_AlgLstVDA *&pcontentEncryptionAlgID);
   bool FindAlgIds(CSM_AlgVDA *pdigestAlgID,
                   CSM_AlgVDA *pdigestEncryptionAlgID,
                   CSM_AlgVDA *pkeyEncryptionAlgID,
                   CSM_AlgVDA *pcontentEncryptionAlgID);
   CSM_AlgVDA *DeriveMsgAlgFromCert(CSM_AlgVDA &Alg);

   //SNACC::CSM_ErrorBuf *m_pErrorBuf; // usually points to CSMIME error buf

};

CSM_CtilInst LIBCTILMGRDLL_API *GLOBALAddLoginFinishCTIL(
   CSM_CtilMgr &Csmime,
   CSM_TokenInterface *pTokenInterface, // IN, actual instance, setup to 
                                        //  specific CTIL.
   char *lpszID);        // IN,OUT id of specific login.

// THIS 2nd version handles a libCert CSM_CSInst instance, which inherits
//  CSM_CtilInst.  The 1st version (above) creates the simpler, non-cert 
//  based instance.
CSM_CtilInst LIBCTILMGRDLL_API *GLOBALAddLoginFinishCTIL(CSM_CtilMgr &Csmime,
   CSM_CtilInst *pNewInstance,     // INPUT
   CSM_TokenInterface *pTokenInterface, // IN, actual instance, setup to 
                                        //  specific CTIL.
   char *lpszID);       // IN,OUT id of specific login.



//#####################################################
// THIS special class was created for the sole purpose of
//  copying the "const char *" data (stack included) from the
//  SNACC::SnaccException.  This is only necessary if the
//  DLL that threw the exception was unloaded before the 
//  application can access the data.
class LIBCTILMGRDLL_API CTILException: public SNACC::SnaccException
{
public:
	CTILException(const CTILException &o) throw();
   CTILException(const SNACC::SnaccException &o) throw();
	virtual ~CTILException() throw();

	CTILException & operator=(const CTILException &that);
    CTILException & operator=(const SNACC::SnaccException &that);
	// overload SnaccException::getCallStack();
	void getCallStack(std::ostream &os) const;

private:
   std::stringstream m_ss;
};

#define SME_SETUP(pszFuncName)  const char *_func=pszFuncName; try   {
#define SME_CATCH_SETUP         catch (SNACC::SnaccException &Exception) {
#define SME_THROW(lErrorCode, _what, Ignore) \
     throw SNACC::SnaccException(STACK_ENTRY, _what, lErrorCode);
//RWC;2/5/03;#define SME_SETUP(pszFuncName)  const char *_func=pszFuncName; try   {
//RWC;2/5/03;#define SME_CATCH_SETUP         catch (CTIL::CSMException &Exception) {
//RWC;2/5/03;#define SME_THROW(lErrorCode, _what, Ignore) 
//RWC;2/5/03;     throw CTIL::CSMException(STACK_ENTRY, _what, lErrorCode);
#define SME_FINISH }
#ifndef _DEBUG
#define SFL_CATCH_FINISH_END  SME_THROW(33, "Unexpected exception thrown!", NULL);\
   }
#define SFL_CATCH_FINISH2        \
      Exception.push(STACK_ENTRY);\
      throw;\
   }\
   catch (...) {
#else    //_DEBUG
//#######################################################
//#######################################################
//###########RWC;SHOULD NOT BE USED; DEBUG ONLY
#define SFL_CATCH_FINISH_END  }
#define SFL_CATCH_FINISH2        \
      Exception.push(STACK_ENTRY);\
      throw;\
   }\
if (0) {     // FAKE Exception; to avoid logic.
//#######################################################
//#######################################################
#endif   //_DEBUG


#define SME_CATCH_FINISH SFL_CATCH_FINISH2 SFL_CATCH_FINISH_END
#define SME(P1) P1          // NO-OP for now, no line number tracking...
#define SME_FINISH_CATCH } SME_CATCH_SETUP SME_CATCH_FINISH
//     e.getCallStack(std::cout);
//////////////////////////////////////////////////////////////////////////
// this macro completes the catch block.  It is the C version of 
// SME_CATCH_FINISH in that it does not throw the exception again
#define SME_CATCH_FINISH_C /*Exception*/ }
//////////////////////////////////////////////////////////////////////////
// this macro completes the catch block.  It is the C version of 
// SME_CATCH_FINISH that does print the errors
#define SME_CATCH_FINISH_C2(P1)  P1 = (char *)calloc(1, \
    strlen(Exception.what()) + strlen("\n errorCode=") + 2 + 40 + \
    strlen("###IN _func=") + strlen(_func) + 6); \
    sprintf(P1, "###IN _func=%s ### %s\n errorCode=%d (%xx)\n", _func, Exception.what(), \
    (int)Exception.m_errorCode, (unsigned int)Exception.m_errorCode); }
//////////////////////////////////////////////////////////////////////////
// This macro finishes the catch block, deletes CSM_Exception, and prints
// the stack to standard out.
#define SME_CATCH_FINISH_APP \
   std::cout << "ERROR INFORMATION AND STACK:\n\n"; \
   Exception.getCallStack(std::cout); std::cout.flush ();   }
//////////////////////////////////////////////////////////////////////////
//  END NEW DEFINITIONS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 


//////////////////////////////////////////////////////////////////////////
// SME_FINISH_CATCH_APP macro is intended for routines that require
// no cleanup and want to report the stack to stdout.
#define SME_FINISH_CATCH_APP    } SME_CATCH_SETUP SME_CATCH_FINISH_APP

//############################################################################


_END_CTIL_NAMESPACE 


#endif // _SM_APICTILMGR_H_
// EOF sm_apiCtilMgr.h
